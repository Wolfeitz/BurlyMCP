# =============================================================================
# BURLY MCP SERVER CONFIGURATION
# =============================================================================
# Copy this file to .env and customize the values for your environment
# 
# SECURITY WARNING: Never commit the actual .env file to version control!
# This template contains examples and documentation for all configuration options.

# =============================================================================
# CORE PATHS AND DIRECTORIES
# =============================================================================

# Base configuration directory (contains policy files, etc.)
# SECURITY: This directory should be read-only for the application
# Default: /app/config (in container) or ./config (development)
BURLY_CONFIG_DIR=/app/config

# Base log directory for all application logs
# SECURITY: Must be writable by application user, protect from unauthorized access
# Default: /var/log/agentops (production) or ./logs (development)
BURLY_LOG_DIR=/var/log/agentops

# =============================================================================
# LOGGING CONFIGURATION
# =============================================================================

# Application log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
# Development: DEBUG or INFO, Production: WARNING or ERROR
LOG_LEVEL=INFO

# Specific log directory (legacy compatibility)
# DEPRECATED: Use BURLY_LOG_DIR instead
LOG_DIR=/var/log/agentops

# =============================================================================
# POLICY AND SECURITY CONFIGURATION
# =============================================================================

# Path to the policy configuration file (relative to BURLY_CONFIG_DIR)
# SECURITY: This file defines tool availability and security constraints
# Must be readable by application, should be version controlled
POLICY_FILE=policy/tools.yaml

# Enable/disable audit logging (true/false)
# SECURITY: Always enable in production for compliance and security monitoring
AUDIT_ENABLED=true

# Path to the audit log file (JSONL format)
# SECURITY: Contains sensitive operation logs - protect with appropriate permissions
# Supports log rotation - use .jsonl extension for proper parsing
AUDIT_LOG_PATH=/var/log/agentops/audit.jsonl

# Directory for audit logs (legacy compatibility)
# DEPRECATED: Use AUDIT_LOG_PATH instead
AUDIT_LOG_DIR=/var/log/agentops

# Comma-separated list of additional sensitive environment variable names
# These will be redacted in audit logs for security
# Example: "CUSTOM_SECRET,API_KEY,DATABASE_PASSWORD"
AUDIT_SENSITIVE_ENV_VARS=

# =============================================================================
# DOCKER INTEGRATION CONFIGURATION
# =============================================================================

# Docker socket path for container operations
# SECURITY: Mounting Docker socket grants significant privileges - use carefully
# Production: Consider Docker-in-Docker or remote Docker API instead
DOCKER_SOCKET=/var/run/docker.sock

# Default timeout for Docker operations (seconds)
# Prevents hanging operations, adjust based on expected container startup times
DOCKER_TIMEOUT=30

# =============================================================================
# BLOG OPERATIONS CONFIGURATION
# =============================================================================

# Root directory for blog staging operations
# SECURITY: Files outside this directory cannot be accessed by blog tools
# Must be writable by application user, should be backed up regularly
BLOG_STAGE_ROOT=/app/blog/stage

# Root directory for blog publishing operations  
# SECURITY: Published content will be written here - ensure proper permissions
# Should be served by web server or CDN, consider read-only after publishing
BLOG_PUBLISH_ROOT=/app/blog/publish

# =============================================================================
# RESOURCE LIMITS AND PERFORMANCE
# =============================================================================

# Default timeout for tool execution (seconds)
# Prevents runaway processes, adjust based on expected tool execution times
DEFAULT_TIMEOUT_SEC=30

# Global default timeout override for all tools (seconds)
# Takes precedence over DEFAULT_TIMEOUT_SEC
TOOL_TIMEOUT_DEFAULT=30

# Maximum output size before truncation (bytes)
# Prevents excessive memory usage - 1MB default (1048576 bytes)
# Adjust based on expected tool output and available memory
MAX_OUTPUT_SIZE=1048576

# Legacy output limit (bytes) - for backward compatibility
# DEPRECATED: Use MAX_OUTPUT_SIZE instead
OUTPUT_TRUNCATE_LIMIT=10240

# Global default output limit override for all tools (bytes)
# Takes precedence over MAX_OUTPUT_SIZE
TOOL_OUTPUT_LIMIT_DEFAULT=1048576

# Maximum number of concurrent tool executions
# Prevents resource exhaustion, adjust based on system capabilities
MAX_CONCURRENT_TOOLS=5

# =============================================================================
# TOOL-SPECIFIC CONFIGURATION
# =============================================================================

# Tool-specific timeout overrides (seconds)
# Format: TOOL_TIMEOUT_{TOOL_NAME_UPPER}
# Example configurations:
# TOOL_TIMEOUT_DOCKER=60
# TOOL_TIMEOUT_BLOG=45
# TOOL_TIMEOUT_SYSTEM=15

# Tool-specific output limit overrides (bytes)
# Format: TOOL_OUTPUT_LIMIT_{TOOL_NAME_UPPER}
# Example configurations:
# TOOL_OUTPUT_LIMIT_DOCKER=2097152
# TOOL_OUTPUT_LIMIT_BLOG=524288
# TOOL_OUTPUT_LIMIT_SYSTEM=1048576

# =============================================================================
# NOTIFICATION CONFIGURATION
# =============================================================================

# Enable/disable all notifications (true/false)
# Set to false to disable all notification providers
NOTIFICATIONS_ENABLED=true

# Notification provider configuration
# Comma-separated list of enabled providers: gotify,webhook,console
# Example: "gotify,console" or "webhook" or "console"
NOTIFICATION_PROVIDERS=console

# --- Gotify Notification Provider ---
# Gotify server URL for push notifications
# SECURITY: Use HTTPS in production, validate SSL certificates
# Example: https://gotify.example.com
GOTIFY_URL=

# Gotify application token for sending notifications
# SECURITY: Keep this token secret - it allows sending notifications to your server
# Generate in Gotify web interface: Apps -> Create Application
GOTIFY_TOKEN=

# Gotify request timeout (seconds)
# Adjust based on network latency and server response times
GOTIFY_TIMEOUT=10

# --- Webhook Notification Provider ---
# HTTP webhook URL for notifications
# SECURITY: Use HTTPS, implement proper authentication on receiving end
# Example: https://api.example.com/webhooks/notifications
WEBHOOK_NOTIFICATION_URL=

# Webhook request timeout (seconds)
WEBHOOK_TIMEOUT=10

# Additional webhook headers (JSON format)
# Example: {"Authorization": "Bearer token", "X-Source": "burly-mcp"}
WEBHOOK_HEADERS=

# =============================================================================
# SERVER IDENTIFICATION
# =============================================================================

# Server name for identification in logs and notifications
# Used in audit logs, notifications, and error messages
SERVER_NAME=burly-mcp

# Server version identifier
# Usually set automatically by the application, can override for testing
SERVER_VERSION=1.0.0

# =============================================================================
# CONTAINER AND DEPLOYMENT CONFIGURATION
# =============================================================================

# User ID for running the application (security best practice)
# SECURITY: Never use root (0) - use unprivileged user ID
# Standard non-root user: 1000
PUID=1000

# Group ID for running the application
# Should match PUID for consistency
PGID=1000

# Python path configuration (usually set automatically)
# Only needed if running outside container with non-standard layout
# PYTHONPATH=/app/src

# Python unbuffered output (recommended for containers)
# Ensures logs are flushed immediately for better debugging
PYTHONUNBUFFERED=1

# =============================================================================
# DEVELOPMENT AND TESTING CONFIGURATION
# =============================================================================

# Development mode flag (true/false)
# Enables additional debugging, more verbose logging, relaxed security
# SECURITY: Never enable in production
DEVELOPMENT_MODE=false

# Test environment flag (true/false)
# Used by test suites to modify behavior (mock external services, etc.)
TEST_MODE=false

# =============================================================================
# VALIDATION EXAMPLES AND DEFAULTS
# =============================================================================

# Example valid configurations for different environments:

# --- Development Environment ---
# BURLY_CONFIG_DIR=./config
# BURLY_LOG_DIR=./logs
# LOG_LEVEL=DEBUG
# BLOG_STAGE_ROOT=./test_data/blog/stage
# BLOG_PUBLISH_ROOT=./test_data/blog/publish
# DEVELOPMENT_MODE=true
# NOTIFICATIONS_ENABLED=false

# --- Production Environment ---
# BURLY_CONFIG_DIR=/app/config
# BURLY_LOG_DIR=/var/log/agentops
# LOG_LEVEL=WARNING
# AUDIT_ENABLED=true
# BLOG_STAGE_ROOT=/data/blog/stage
# BLOG_PUBLISH_ROOT=/data/blog/publish
# GOTIFY_URL=https://notifications.company.com
# GOTIFY_TOKEN=A1B2C3D4E5F6...
# NOTIFICATIONS_ENABLED=true
# NOTIFICATION_PROVIDERS=gotify

# --- Docker Production Environment ---
# BURLY_CONFIG_DIR=/app/config
# BURLY_LOG_DIR=/var/log/agentops
# DOCKER_SOCKET=/var/run/docker.sock
# PUID=1000
# PGID=1000
# PYTHONUNBUFFERED=1

# =============================================================================
# SECURITY BEST PRACTICES AND WARNINGS
# =============================================================================

# 1. FILE PERMISSIONS AND ACCESS CONTROL:
#    - Configuration directory (BURLY_CONFIG_DIR): Read-only for application
#    - Log directory (BURLY_LOG_DIR): Writable by application user only
#    - Blog directories: Appropriate read/write permissions, regular backups
#    - Audit logs: Restricted access, consider centralized log management
#    - Never run as root user (PUID=0) in production

# 2. NETWORK SECURITY:
#    - Use HTTPS for all external URLs (Gotify, webhooks)
#    - Validate SSL certificates in production
#    - Consider network isolation and firewall rules
#    - Implement rate limiting for notification endpoints
#    - Use VPN or private networks for sensitive communications

# 3. SECRET MANAGEMENT:
#    - Never hardcode secrets in configuration files
#    - Use Docker secrets, Kubernetes secrets, or external secret managers
#    - Rotate tokens and passwords regularly
#    - Monitor for exposed secrets in logs and audit trails
#    - Consider using environment-specific secret injection

# 4. RESOURCE PROTECTION:
#    - Set appropriate timeouts to prevent DoS attacks
#    - Monitor resource usage and adjust limits based on capacity
#    - Implement container resource limits (CPU, memory)
#    - Use read-only filesystems where possible
#    - Regular security updates and vulnerability scanning

# 5. AUDIT AND MONITORING:
#    - Enable audit logging in all environments
#    - Regularly review audit logs for suspicious activity
#    - Implement log rotation to prevent disk space issues
#    - Set up alerting for security events and failures
#    - Consider centralized logging and SIEM integration

# 6. DOCKER SECURITY:
#    - Minimize Docker socket access - consider alternatives
#    - Use specific image tags, not 'latest'
#    - Scan images for vulnerabilities regularly
#    - Drop unnecessary Linux capabilities
#    - Use non-root users in containers

# 7. OPERATIONAL SECURITY:
#    - Regular backups of configuration and data
#    - Disaster recovery procedures
#    - Security incident response plan
#    - Regular security assessments and penetration testing
#    - Keep dependencies updated and patched